---
title: "The effect of bacteria on the *A. thaliana* Pi starvation response"
author: "Sur Herrera Paredes"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
bibliography: references.bib
---

This document was created for the workshop **Data Management for Publishing:
Accessibility and Reproducibility**, to be taught on April 23rd, 2022. All
resources for the Rmarkdown session of the workshop, plus some additional
ones, can be found in the GitHub repository
[surh/Rmarkdown_workshop](https://github.com/surh/Rmarkdown_workshop).

The data and code in this document reproduce some of the analysis from
@HerreraParedes2018. The full data and code from that publication can be found
in the GitHub repository [surh/wheelP](https://github.com/surh/wheelP).

# Setup

The first step is to load the packages and data that we need for analysis.
We will use the [tidyverse](https://www.tidyverse.org/) collection of packages.

We do that by creating our first R code chunk, which should start with the
line ```` ```{r chunk_name} ````,  followed by any R code, and ends with a line
with a triple backtick (```` ``` ````). When we press `Ctrl+Shift+k` in
RStudio, any R code within the code chunk will be run and both the
code and its output will be rendered nicely into an output file.

```{r packages}
library(tidyverse)
```

Now, we read the data which is in the `data` directory of the
[GitHub repository](https://github.com/surh/Rmarkdown_workshop)
of the workshop. Since the input file is a tab-delimited file,
we use the `read_tsv` function from the `readr` package (which
was automatically loaded when we loaded the `tidyverse` package).

After reading the file, we simply print the first few rows to inspect it.

```{r read_data}
Dat <- read_tsv("data/phenotypes.tsv",
                col_types = cols(Pi_content = col_number(),
                                 Elongation = col_number(),
                                 Experiment = col_character(),
                                 EndP = col_character(),
                                 Bacteria = col_character(),
                                 Plate = col_character()))
Dat
```

This dataset contains `r nrow(Dat)` observations. The observations correspond to
a subset of the observations published by @HerreraParedes2018. Specifically,
the dataset indicates the shoot phosphate (Pi) content ($\frac{Pi\ mmol }{FW\ mg}$),
and main root elongation (cm) measurements of *Arabidopsis thaliana* plants that
were germinated in the absence of Pi, and then received concurrent treatments
of one of two levels of Pi ($30 \mu M$, $100 \mu M$), and one of three bacterial
cocktails (P1P2, I1I2, N2N3) or no bacteria (axenic).

# Sanity checks

When *A .thaliana* plants are starved for Pi, they suppress the elongation
of their main root, because in the soils where they live, Pi is located in
the topmost layers.

We confirm that we observe this general trend by plotting the `Elongation`
& `Pi_content` measurements in a scatter plot. We can use the `ggplot`
function from the `ggplot2` package (which also was loaded as part of the
`tidyverse` package).

Because there are two Pi conditions, we plot each the observations from
each condition in a different color (`col = EndP`), and we add a linear
regression line (i.e. a *trendline*) on each group of observations
with the `geom_smooth` function. Finally, we set the `theme_classic()`
theme which makes for less busy looking plots [^1].

[^1]: The `%>%` symbol in the code below is a pipe (or more formally a 
FIFO operator). It is provided by the `maggrittr` package and loaded with the
`tidyverse`. If you are familiar with UNIX/Linux systems, it works very similar
to the shell `|` operator. Its operation is very simple, it just takes the
output of its expression on the left, and it uses that output as the first
parameter of the expression on its right.

```{r plot_phenotypes, fig.cap="Scatter plot of main root elongation (Elongation) and shoot Pi content (Pi_content)."}
Dat %>%
  ggplot(aes(x = Pi_content, y = Elongation, col = EndP)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ x) +
  theme_classic()
```

We observe that there are three apparent outliars in the bottom left corner
of the plot. It is important to investigate those further, so we sort the
dataset by Elongation to investigate further. We can do that with the `arrange`
function of the `dplyr` package, which is another one of those packages
automagically loaded when loading `tidyverse`. By default, `arrange` sorts
things in increasing order.

```{r explore_outliars}
Dat %>%
  arrange(Elongation)
```

When we examine the observation with the three smalles elongation
measurements, we note that all come from the same experiment and
treatment. It seems likely that something went wrong with those
observations, so we should remove them from further analysis.

There is more than one way to do it, but one convenient function is
`filter` which is part of the `dplyr` package, and allows us to specify
a condition that must be met for rows in our dataset to be kept, everything
else is removed.

```{r remove_outliars}
Dat <- Dat %>%
  filter(Elongation > 2)
```

After removing outliars, w have `r nrow(Dat)` observations (i.e. rows) in the
dataset.

It is always a good idea to check that the overall trends didn't change
with the removal of the outliars (and after any type of subsetting). So we
can make the same plot again with the modified datase.

Note that if we just copy the chunk from the first scatter plot (with the
outliars), we would get an error because the chunk names would be the same.
So we need to change the name to something unique before rendering the
RMarkdown file.

```{r plot_phenotypes2, fig.cap="Scatter plot of main root elongation (Elongation) and shoot Pi content (Pi_content) with outliars removed."}
Dat %>%
  ggplot(aes(x = Pi_content, y = Elongation, col = EndP)) +
  geom_point() +
  geom_smooth(method = "lm", formula = y ~ x) +
  theme_classic()
```

Overall, the trends remain the same after we removed the outliars, which
was expected.

## Is the association statiscally supported?

The plots above show that the relationship between plant shoot Pi content
and main root elongation, follow the expected trend, but how strong is the
relationship? and is it statistically supported?

We can quantify the correlation with the `cor` base R function, and
obtain a *p*-value with the `cor.test()` function which outputs a list
with an element named `p.value`.

```{r cor_pval, echo = FALSE}
r <- cor(Dat$Pi_content, Dat$Elongation)
r.pval <- cor.test(Dat$Pi_content, Dat$Elongation)$p.value
```

With these tools, we calculate that the overall correlation between the
Pi content and root elongation phenotypes
is **`r cor(Dat$Pi_content, Dat$Elongation)`** which has a *p*-value
of `r cor.test(Dat$Pi_content, Dat$Elongation)$p.value` which is
`r ifelse(r.pval < 0.05, "", "not")` significant.

However, we want to calculate the correlation independently for each
condition.

* The correlation between the Pi content and root elongation in
the $30 \mu M$ Pi condition is 
**`r cor(Dat$Pi_content[ Dat$EndP == "30 uM,0%Suc" ], Dat$Elongation[ Dat$EndP == "30 uM,0%Suc" ])`**
which has a *p*-value of
`r cor.test(Dat$Pi_content[ Dat$EndP == "30 uM,0%Suc" ], Dat$Elongation[ Dat$EndP == "30 uM,0%Suc" ])$p.value`.

* The correlation between the Pi content and root elongation in
the $100 \mu M$ Pi condition is 
**`r cor(Dat$Pi_content[ Dat$EndP == "100 uM,0%Suc" ], Dat$Elongation[ Dat$EndP == "100 uM,0%Suc" ])`**
which has a *p*-value of
`r cor.test(Dat$Pi_content[ Dat$EndP == "100 uM,0%Suc" ], Dat$Elongation[ Dat$EndP == "100 uM,0%Suc" ])$p.value`.

Thus the effect correlation of between Pi starvation & main root elongation
is stronger when the Pi starvation is more severe.

### Controling for covariates

While we compared the association between the plant phenotypes in two
conditions, the dataset contains another variable, which is the bacterial
cocktail (`Bacteria`) added to the plants, so a full analysis must consider
the effect of the bacterial treatment, as well as the experimental variation
between replicates.

Without going into details, a first approximation to this problem [^2] can
be achieved with the base R `lm` function, which allows us to fit a linear
model that attempts to explain the variation in main root elongation,
as a function of all the other variables (biological & technical).

The statistical model is defined by a `formula` object, which we save
to a variable `f1`. After fitting the model we display the results
with the R base function `summary`.

[^2]: A more complete and appropriate treatment would consider the full
dataset published by @HerreraParedes2018.

```{r full_model}
f1 <- Elongation ~ Pi_content + Bacteria + EndP + Experiment
m1 <- lm(f1, data = Dat)
summary(m1)
```

Here we can see that there are statistically signigicant (i.e. *p*-value < 0.05)
effects for the different bacterial treatments and for some experiments.
However there no effect of the Pi concentration in the media at the
second part of the experiment (EndP), and it seems like the shoot Pi content
is also not statistically significant [^3].

[^3]: Part of the lack of significance has to do with the size of the dataset
and the aggregation level of the data in this example. In the original
publication, there are many more observations and the measurements are less
aggregated.

Given the small sample size, models with a lot of parameters tend to
suffer of something called *over-fitting* which basically means that
the model confuses noise for signal. So in general, it is a good
practice to check if a simpler model can do an equally good job at
explaining your data.

We can thus check whether a model without the `EndP` variable, which had
the largest *p*-value in the previous model. To do that, we change the formula
by removing that variable, fit the new (`m2`) model and then we perform a
Likelihood Ratio Test (LRT) with the base R `anova` function. You can do
all this much more simply with the `lmtest` package, but we are restricting
ourselves here to base functions.

```{r nested_model}
f2 <- Elongation ~ Pi_content + Bacteria + Experiment
m2 <- lm(f2, data = Dat)
anova(m1, m2, test = "LRT")
```

The *p*-value in the output above is clearly above 0.05 and thus it indicates
clearly that there is no significant difference in explanatory power
between the models. Thus we select the simpler one (`m2`) and we
display the results with the base R `summary` function.

```{r model_summary}
summary(m2)
```

The output above now shows that shoot Pi content does have a significant
effect on main root elongation as we expected, thus even after accounting for
other sources of variation, the relationship between these two plant
phenotypes remains.

The output of summary contains a lot of useful information, but sometimes
we are interested just in the table of coeffients and *p*-values, which
is what is typically reported in scientific publications. We could
simply `summary(m2)$coefficients` which access the `coefficients` table
produced by the `summary` function, but that still displays the
results as R output which is not necessarily the most easy to read or export.

We could also save the resutls to a file with functions like `write_tsv`
or `write_csv` of the readr package (or `write.table` from base R), but then
we lose the advantage of displaying code and output together.

Instead, we can convert any matrix or data.frame into a Markdown formatted
table with the `kable` function of the knitr package. Since we haven't
loaded this package we can access the function with the `package::function`
syntax which tells R in which package (or more technically namespace) a
function is. For the `kable` function to work we also need to set the
`results = "asis"` option in the code chunk options. Finally we can
add a caption with the `caption` option of the `kable` function.

```{r coef_table, echo = FALSE, results = "asis"}
knitr::kable(summary(m2)$coefficients,
             caption = paste("Coefficients of linear model (",
                             format(f2), ").",
                             "We observe that shoot Pi content has no significant",
                             "effect on main root elongation."))
```

# Recreating figure 3C

![Fig. 3C from @HerreraParedes2018](figs/Fig3C.jpeg)

```{r, echo = FALSE}
test_phenotype <- function(Dat, phenotype){
  f1 <- paste(phenotype, "~", "Bacteria + Experiment")
  f1 <- as.formula(f1)
  
  m1 <- lm(f1, data = Dat)
  Res <- summary(m1)$coefficients
  
  Res <- as.data.frame(Res)
  Res$var <- row.names(Res)
  row.names(Res) <- NULL
  Res <- Res %>%
    filter(var %in% c("BacteriaI1I2", "BacteriaN2N3", "BacteriaP1P2" )) %>%
    mutate(phenotype = phenotype) %>%
    rename(se = "Std. Error",
           t.value = "t value",
           p.value = "Pr(>|t|)")
  
  return(Res)
}
```

## Bacteria effect on shoot Pi content

```{r}
Pi_res <- bind_rows(test_phenotype(Dat = Dat %>%
                                     filter(EndP == "30 uM,0%Suc"),
                                   phenotype = "Pi_content") %>%
                      mutate(EndP = "30 uM"),
                    test_phenotype(Dat = Dat %>%
                                     filter(EndP == "100 uM,0%Suc"),
                                   phenotype = "Pi_content") %>%
                      mutate(EndP = "100 uM"))
Pi_res
```


## Bacteria effect on main root elongation

```{r}
Elo_res <- bind_rows(test_phenotype(Dat = Dat %>%
                                      filter(EndP == "30 uM,0%Suc"),
                                    phenotype = "Elongation") %>%
                       mutate(EndP = "30 uM"),
                     test_phenotype(Dat = Dat %>%
                                      filter(EndP == "100 uM,0%Suc"),
                                    phenotype = "Elongation") %>%
                       mutate(EndP = "100 uM"))
Elo_res
```

## Combine the results

```{r}
Res <- bind_rows(Pi_res, Elo_res) %>%
  mutate(SynCom = str_remove(var, "^Bacteria")) %>%
  select(-var)
Res
```

```{r, out.width="50%", fig.show='hold', fig.cap="**Left**: Estimates of bacterial effect on two plant phenotypes. **Right**: Similar estimates from @HerreraParedes2018."}
Res %>%
  mutate(significant = c("", "X")[ (p.value < 0.05) + 1 ]) %>%
  mutate(SynCom = factor(SynCom,levels = rev(c("P1P2", "I1I2", "N2N3"))),
         phenotye = factor(phenotype, levels = c("Pi_content", "Elongation"))) %>%
  ggplot(aes(x = EndP, y = SynCom)) +
  facet_wrap(~phenotype) +
  geom_tile(aes(fill = t.value)) +
  geom_text(aes(label = significant), size = 12) +
  scale_fill_gradient2(low = "magenta", mid = "white", high = "green",
                       midpoint = 0) +
  guides(fill = guide_legend(title = "Scaled Effect", title.position = "left")) +
  theme(panel.background = element_blank(),
        axis.text = element_text(color = "black"),
        axis.title.y = element_text(face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90, vjust = 0.5),
        legend.title = element_text(face = "bold", angle = 90),
        strip.background = element_blank(),
        strip.text = element_text(color = "black", face = "bold", size = 20))
knitr::include_graphics("figs/Fig3C.jpeg")
```

# Session Info

```{r}
sessionInfo()
```



# References





